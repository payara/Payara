#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010-2013 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://github.com/payara/Payara/blob/main/LICENSE.txt
# See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at legal/OPEN-SOURCE-LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

create.jvm.options=cria op\u00e7\u00f5es JVM na configura\u00e7\u00e3o Java ou elemento do gerador de perfil do arquivo domain.xml.
create.jvm.options.jvm_option_name=O lado esquerdo do sinal de igual (=) \u00e9 o nome da op\u00e7\u00e3o JVM. O lado direito do sinal de igual (=) \u00e9 o valor da op\u00e7\u00e3o JVM. Dois-pontos (:) \u00e9 o delimitador para v\u00e1rias op\u00e7\u00f5es.
create.jvm.options.usagetext=create-jvm-options\n\t[--target <target(default:server)>]\n\t[--min-jvm=<vers\u00e3o>]\n\t[--max-jvm=<vers\u00e3o>]\n\t[-?|--help[=<help(default:false)>]]\n\t(jvm_option_name[=jvm_option_value])[:jvm_option_name[=jvm_option_name]]*
delete.jvm.options=remove op\u00e7\u00f5es JVM da configura\u00e7\u00e3o Java ou elementos do gerador de perfil do arquivo domain.xml.
delete.jvm.options.jvm_option_name=O lado esquerdo do sinal de igual (=) \u00e9 o nome da op\u00e7\u00e3o JVM. O lado direito do sinal de igual (=) \u00e9 o valor da op\u00e7\u00e3o JVM. Dois-pontos (:) \u00e9 o delimitador para v\u00e1rias op\u00e7\u00f5es.
delete.jvm.options.usagetext=delete-jvm-options\n\t[--target <target(default:server)>]\n\t[-?|--help[=<help(default:false)>]]\n\t(jvm_option_name[=jvm_option_value])[:jvm_option_name[=jvm_option_name]]*
list.jvm.options=lista op\u00e7\u00f5es JVM na configura\u00e7\u00e3o Java ou elemento do gerador de perfil do arquivo domain.xml.
list.jvm.options.success=Listagem com sucesso das op\u00e7\u00f5es JVM configuradas e propriedades do sistema Java em determinado destino
list.jvm.options.failed=Falha ao listar op\u00e7\u00f5es JVM em determinado destino por este motivo: {0}
create.jvm.options.success=Cria\u00e7\u00e3o com sucesso de determinadas op\u00e7\u00f5es no destino especificado
delete.jvm.options.success=Dele\u00e7\u00e3o com sucesso de determinadas op\u00e7\u00f5es no destino especificado
delete.jvm.options.failed=Falha ao deletar determinadas op\u00e7\u00f5es no destino especificado pelo seguinte motivo,\nas op\u00e7\u00f5es atuais de configura\u00e7\u00e3o foram conservadas
created.message={0} Op\u00e7\u00e3o(\u00f5es) Criada(s)
no.option.created=N\u00e3o foi criada nenhuma op\u00e7\u00e3o JVM (talvez j\u00e1 exista)
deleted.message={0} Op\u00e7\u00e3o(\u00f5es) Deletada(s)
no.option.deleted=N\u00e3o foi deletada nenhuma op\u00e7\u00e3o JVM (talvez nunca houve alguma na configura\u00e7\u00e3o)
joe.exists=A op\u00e7\u00e3o JVM {0} j\u00e1 existe na configura\u00e7\u00e3o.
joe.invalid.start=A op\u00e7\u00e3o JVM {0} \u00e9 inv\u00e1lida porque n\u00e3o come\u00e7a com "-"
joe.invalid.cmd.syntax=A linha de comando:{0} n\u00e3o obedece \u00e0 sintaxe.\nEm um nutshell, todas as op\u00e7\u00f5es devem come\u00e7ar com "-", v\u00e1rias op\u00e7\u00f5es s\u00e3o separadas por ":".\nUm ":" na op\u00e7\u00e3o deve ser escapado com "\\".\nComo o shell interpreta argumentos do comando, certifique-se de coloc\u00e1-lo entre aspas.\n
soft.invalid.xmx=Parece que a op\u00e7\u00e3o JVM {0} fornecida representa um heap m\u00e1ximo inv\u00e1lido para a JVM. Certifique-se de que seja v\u00e1lida atrav\u00e9s de list-jvm-options.
soft.xmx.exists=A configura\u00e7\u00e3o j\u00e1 possui um tamanho m\u00e1ximo de heap especificado: {0}. Verifique a configura\u00e7\u00e3o java utilizando list-jvm-options.
soft.xmx.smaller.than.xms=Parece que o tamanho m\u00e1ximo de heap especificado {0} \u00e9 menor que o tamanho m\u00ednimo de heap na configura\u00e7\u00e3o: {1}. A JVM pode n\u00e3o ser iniciada. Certifique-se de que esse valor \u00e9 v\u00e1lido utilizando list-jvm-options.
soft.invalid.xms=Parece que a op\u00e7\u00e3o JVM {0} fornecida representa um heap inicial inv\u00e1lido para a JVM. Certifique-se de que esse valor \u00e9 v\u00e1lido utilizando list-jvm-options.
soft.xms.exists=A configura\u00e7\u00e3o j\u00e1 tem um tamanho inicial de heap especificado: {0}. Verifique a configura\u00e7\u00e3o java utilizando list-jvm-options.
soft.xms.larger.than.xmx=Parece que o tamanho inicial de heap especificado {0} \u00e9 maior que o tamanho m\u00e1ximo de heap na configura\u00e7\u00e3o: {1}. A JVM pode n\u00e3o ser iniciada. Certifique-se de esse valor \u00e9 v\u00e1lido utilizando de list-jvm-options.
#Generate JVM Report
server.unreachable=O servidor {0} parece estar inalcan\u00e7\u00e1vel. Isso significa que n\u00e3o est\u00e1 em execu\u00e7\u00e3o ou existe erro interno de comunica\u00e7\u00e3o.
td.title=Dump Completo de Thread Java {0} {1} {2}
thread.no=N\u00famero de threads: {0}
daemon.thread.no=N\u00famero de threads de daemon: {0}
peak.thread.no=Contagem m\u00e1xima de threads em atividade desde que a m\u00e1quina virtual Java iniciou ou a contagem m\u00e1xima foi redefinida: {0}
thread.contention.monitoring.supported=O suporte ao monitoramento da disputa por threads est\u00e1 dispon\u00edvel nesta JVM? [{0}]
thread.contention.monitoring.enabled=O monitoramento de disputa por threads est\u00e1 ativado? [{0}]. Se falso, algumas estat\u00edsticas de sincroniza\u00e7\u00e3o de threads n\u00e3o est\u00e3o dispon\u00edveis.
thread.cputime.supported=O suporte \u00e0 medi\u00e7\u00e3o de tempo da CPU para qualquer thread est\u00e1 dispon\u00edvel nesta JVM? [{0}]
thread.cputime.enabled=A medi\u00e7\u00e3o de tempo da CPU est\u00e1 ativada? [{0}]. Se falso, as horas de execu\u00e7\u00e3o de threads n\u00e3o est\u00e3o dispon\u00edveis para qualquer thread.
execution.info=Informa\u00e7\u00f5es sobre Execu\u00e7\u00e3o de Threads:
thread.title=Thread {0} ID do thread: {1} estado do thread: {2}
thread.waiting.on=Aguardando bloqueio: {0}
thread.suspended=Suspenso
thread.in.native=Em execu\u00e7\u00e3o em nativo
thread.stack.element=\t em: {0}
no.deadlock=Nenhum impasse encontrado
sync.info=Estat\u00edstica de Sincroniza\u00e7\u00e3o de Threads:
thread.blocked.times=N\u00famero de vezes que este thread foi bloqueado (para inserir/inserir novamente um Monitor): {0}
thread.blocked.totaltime=Total (aproximado) de vezes que o thread permaneceu no estado BLOQUEADO: {0} milissegundos desde que o monitoramento de disputa por threads foi ativada pela \u00faltima vez.
thread.total.cpu.time=Tempo total da CPU para este thread: {0} segundos {1} nanossegundos.
thread.cpu.user.time=Tempo da CPU no n\u00edvel do usu\u00e1rio para este thread: {0} segundos {1} nanossegundos.
wait.times=N\u00famero de vezes que este thread aguardou uma notifica\u00e7\u00e3o (isto \u00e9, estava no estado AGUARDANDO ou AGUARDANDO_VEZES): {0}
lock.owner.details=Este thread est\u00e1 bloqueado e aguarda o bloqueio no momento pertencente ao thread nomeado: {0}, ID: {1}
monitor.info=Monitores de objeto mantidos ou solicitados no momento por este thread: {0}
ownable.sync.info=Sincronizadores poss\u00edveis propriet\u00e1rios (por exemplo, ReentrantLock e ReentrantReadWriteLock) mantidos por este thread: {0}
deadlocks.found=Estes threads estavam em um impasse:
m2hms={0} Horas {1} Minutos {2} Segundos
m2sms={0} Segundos {1} Milissegundos
uptime=Tempo de atividade da m\u00e1quina virtual Java: {0}
memory.pool.name=Nome do Pool de Mem\u00f3ria: {0}
memory.usage.init=Mem\u00f3ria que a m\u00e1quina virtual Java solicitou inicialmente ao sistema operacional: {0} Bytes
memory.usage.comm=Garantia de mem\u00f3ria que a m\u00e1quina virtual Java receber\u00e1 do sistema operacional: {0} bytes
memory.usage.max=Mem\u00f3ria m\u00e1xima que a m\u00e1quina virtual Java pode obter do sistema operacional: {0} bytes. Observe que isso n\u00e3o \u00e9 garantido.
memory.usage.used=Mem\u00f3ria que a m\u00e1quina virtual Java usa neste momento: {0} bytes
gc.name=Nome do coletor de lixo: {0}
gc.numcol=N\u00famero de coletas ocorridas usando este coletor de lixo: {0} bytes
gc.coltime=Hora da Coleta de Lixo: {0}
heap.mem.usage=Utiliza\u00e7\u00e3o de Mem\u00f3ria Heap:
nonheap.mem.usage=Utiliza\u00e7\u00e3o de Mem\u00f3ria N\u00e3o Heap:
obj.fin.pending=N\u00famero aproximado de objetos para os quais a finaliza\u00e7\u00e3o est\u00e1 pendente: {0}
classloading.info=Carregando e descarregando classes na m\u00e1quina virtual Java:
classes.loaded=N\u00famero de classes carregadas no momento na m\u00e1quina virtual Java: {0}
classes.total=N\u00famero de classes carregadas na m\u00e1quina virtual Java desde a inicializa\u00e7\u00e3o: {0}
classes.unloaded=N\u00famero de classes descarregadas da m\u00e1quina virtual Java: {0}
complilation.info=Informa\u00e7\u00f5es de compila\u00e7\u00e3o Just-in-time (JIT) na m\u00e1quina virtual Java:
compilation.monitor.status=Monitoramento de compila\u00e7\u00e3o na m\u00e1quina virtual Java permitida: {0}
jit.compilar.name=Nome do compilador Just-in-time (JIT): {0}
compilation.time=Tempo total gasto na compila\u00e7\u00e3o: {0}
os.info=Informa\u00e7\u00f5es do Sistema Operacional:
os.name=Nome do sistema operacional: {0}
os.arch=Nome da arquitetura bin\u00e1ria do sistema operacional: {0}, Vers\u00e3o: {1}
os.nproc=N\u00famero de processadores dispon\u00edveis no sistema operacional: {0}
os.load=Carga de sistema nos processadores dispon\u00edveis no \u00faltimo minuto: {0}. (Soma de entidades em execu\u00e7\u00e3o e execut\u00e1veis em fila por minuto)
rt.info=Informa\u00e7\u00f5es gerais sobre Java Runtime Environment da VM: {0}
rt.bcp=BootClassPath de JRE: {0}
rt.cp=ClassPath de JRE: {0}
rt.libpath=Caminho da Biblioteca Nativa de JRE: {0}
rt.nvv=Nome de JRE: {0} Fornecedor: {1} Vers\u00e3o: {2}
rt.sysprops=Lista de propriedades de sistema da m\u00e1quina virtual Java:
summary.title=**** M\u00e1quina virtual Java [Nome da Inst\u00e2ncia do Servidor de Aplica\u00e7\u00f5es: {0}] Resumo ****
class.info.title=**** Estat\u00edstica de classe da m\u00e1quina virtual Java [Nome da inst\u00e2ncia do servidor de aplica\u00e7\u00f5es: {0}] ****
thread.dump.title=**** Dump de Thread da M\u00e1quina Virtual Java [Nome da inst\u00e2ncia do Servidor de Aplica\u00e7\u00f5es: {0}] ****
memory.info.title=**** Informa\u00e7\u00f5es sobre mem\u00f3ria (Perm Gen, Eden Space etc.) da m\u00e1quina virtual Java [Nome da inst\u00e2ncia do servidor de aplica\u00e7\u00f5es: {0}] ****
#logging information
logging.config.file=Arquivo efetivo de propriedades de log: [{0}]. Se nulo, indica o arquivo JRE padr\u00e3o.
reg.loggers=N\u00famero de loggers atualmente registrados na JVM: [{0}]. Detalhes a seguir:
logger.details.1=Se o n\u00edvel estiver em branco, ele \u00e9 herdado do logger pai
logger.details.2=O logger pai \u00e9 logger pai mais pr\u00f3ximo existente
list.of.loggers=Nome do Logger | N\u00edvel de Log | Nome do Logger Pai
create.threadpool.duplicate=O Pool de Threads {0} j\u00e1 existe.
create.threadpool.failed=Falha ao criar: {0} por causa de: {1}
create.threadpool.deprecated.workqueues=Sintaxe obsoleta: a op\u00e7\u00e3o --workqueues est\u00e1 obsoleta para o comando create-threadpool.
list.thread.pools.failed=Falha ao listar Pool de Threads por causa de: {0}
delete.threadpool.notexists=O Pool de Threads {0} n\u00e3o existe.
delete.threadpool.failed=Falha ao deletar Pools de Threads por causa de: {0}
attach.wrong.commandinstance.id=O job com o id {0} n\u00e3o existe.
attach.finished=O comando {0} foi executado com o status {1}.
unable.to.get.ManagedJobConfig=N\u00e3o \u00e9 poss\u00edvel obter o bean ManagedJobConfig.
failed.to.configure.ManagedJobConfig=Falha ao configurar o bean ManagedJobConfig

getPayload.wrong.commandinstance.id=O job com o id {0} n\u00e3o existe.
getPayload.nopayload=O payload de sa\u00edda n\u00e3o existe.
getPayload.unsupported=O tipo de payload n\u00e3o \u00e9 suportado. N\u00e3o \u00e9 poss\u00edvel fazer download dos dados.
