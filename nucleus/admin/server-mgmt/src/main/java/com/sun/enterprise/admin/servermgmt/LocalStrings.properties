#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010-2013 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#
# Portions Copyright [2018] [Payara Foundation and/or its affiliates]
#

validator.invalid_value=Invalid value for {0} : {1}
validator.invalid_type=Invalid type for {0}. Expected {1} or subtype but got {2}
fileValidator.no_read=No read permission: {0}
fileValidator.no_write=No write permission: {0}
fileValidator.not_a_dir={0} is not a directory
portValidator.in_use=Port {0} is in use
domainConfig=domain config
adminUserComment=# Domain User and Password - Do Not Delete Entry Above
keyStoreNotCreated=Error creating key store {0}
trustStoreNotCreated=Error creating trust store {0}
trustStoreJavaImportError=Error importing certificates from Java trust store to trust store {0}
masterPasswordFileNotCreated=Error creating master password file {0}
timerDbnNotCreated=Error creating timer database dbn file
timerWalNotCreated=Error creating timer database wal file
jbiRegistryTemplateNotCopied=Error copying JBI registry template file
installRoot=install root
cannotDeleteJmsProviderInstance=Error deleting mq broker instance
masterPasswordFileNotRead=Error reading master password file {0}

keyStorePasswordNotChanged=Error changing keystore password for store {0}

s1asKeyPasswordNotChanged=Error changing password for default key with alias s1as for store {0}

passwordAliasPasswordNotChanged=Error changing password for password alias store {0}

couldNotValidateMasterPassword=Exception validating master password against store {0}

masterPasswordInvalid=Password entered is invalid
derbyEjbTimerDBNotCreated=The embedded EJB Timer Database could not be created, detailed message: {0}
noDerbyLog=The derby log file could not be read. No detailed information available.
nullArg=Null argument was provided.
smfTokenNeeded=Required token [{0}] initialized with invalid value [{1}]. Set the value correctly using ServiceHandler interface.
invalidTO=Invalid value [{0}] specified as timeout. Only non-negative integers are allowed.
serviceNameInvalid=Invalid name [{0}] for the service.
smfManifestExists=It appears that the manifest file [{0}] already exists. This means that there was a previous attempt to create the service with the same name. Either choose a different name for the service or delete the service and corresponding manifest file and retry. 
smfManifestFolderExists=It appears that the service folder for appserver SMF hierarchy [{0}] already exists. Cannot continue until it is cleaned up.
doesNotExist=The object [{0}] could not be found.
serviceTypeNotSet=Service type is not configured correctly.
serviceTemplateNotFound=Service template [{0}] does not exist, something wrong with setting environment like INSTALL_ROOT etc.
notSolaris10=Present Platform, OS: {0} version: {1} is not Solaris 10. This facility is not supported on platforms other than Solaris 10.
noPermissionToCreateManifest=The user [{0}] does not have permission to create the service manifest related files and directories at [{1}]. This structure is required per SMF guidelines. Either become super-user to do this operation or contact the System Administrator to explicitly get the relevant permissions and try again.
noSmfAuth=The user [{0}] does not seem to have adequate authorizations [solaris.smf.*] on this System to create and configure an SMF service. The authorizations available are [{1}].\nSee smf_security(5), rbac(5).\n
missingParamsInFile=The passwordfile that was specified as [{0}] does not contain the property [{1}] in required form. Rerun the command after adding [{1}=value] to this file on a separate line.
serviceNameExists=An SMF service with name [{0}] appears to exist as shown by [svcs -a] command, on this machine. Retry creating the service with different name provided for the service.
runtimeStatusToString={0} is {1}
fileNotFound=File {0} not found.
error=error
runtimeStatusToStringStopCluster.alreadyStopped=The clustered instance, {0}, was already stopped.
runtimeStatusToStringStopCluster.success=The clustered instance, {0}, was successfully stopped.
runtimeStatusToStringStopCluster.stoppedToRunning=This should be impossible.  The clustered instance, {0}, was stopped and now it is: {1}
runtimeStatusToStringStopCluster.error=The clustered instance, {0}, could not be stopped.  It was originally in this state: [{1}] and now it is in this state: [{2}].
noSuitableServiceImplementation=No suitable service handler found for this platform, service can not be created.
runtimeStatusToStringStartCluster.alreadyStarted=The clustered instance, {0}, was already running.
runtimeStatusToStringStartCluster.success=The clustered instance, {0}, was successfully started.
runtimeStatusToStringStartCluster.startedToStopped=This should be impossible.  The clustered instance, {0}, was running and now it is: {1}
runtimeStatusToStringStartCluster.error=The clustered instance, {0}, could not be started.  It was originally in this state: [{1}] and now it is in this state: [{2}].

CertificateDN=Distinguished Name of the self-signed X.509 Server Certificate is:\n[{0}]
SomeProblemWithKeytool= Domain creation process involves a step that creates primary key and\n self-signed server certificate. This step failed for the reason shown below.\n This could be because JDK provided keytool program could not be found (e.g.\n you are running with JRE) or for some other reason. No need to panic, as you\n can always use JDK-keytool program to do the needful. A temporary JKS-keystore\n will be created. You should replace it with proper keystore before using it for SSL.\n Refer to documentation for details. Actual error is:\n{0}
