#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2013 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: Cannot use multiple combinations of username/password in the same transaction.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory is not configured.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: Operation is not supported for the internal PersistenceManagerFactoryImpl.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: Failed to acquire exclusive lock due to InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: Failed to acquire share lock because _readWriteCount is less than zero
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: Failed to acquire share lock due to InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: Object is associated with another PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: Transaction associated with this persistence manager is not active.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: PersistenceManager is closed.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: Class {0} has not been enhanced for Transparent Persistence. Use the IDE''s JAR or WAR packager to package your persistence-capable classes before running. Or, set the Executor property on the main class to Persistence Executor to run from the IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: There is an open transaction associated with this persistence manager.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: Object not found for this ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: Cannot delete non-persistent object.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: An instance with the same primary key already exists in this PersistenceManager cache.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: Error retrieving object Class from OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: Cannot create SCO instance of class {0} because it is not a valid type.
jdo.persistencemanagerimpl.notprocessed=JDO76018: Unable to flush persistent instances due to circular dependencies.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: Failed to release exclusive lock because _readWriteCount is greater than zero
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: Failed to release share lock because _readWriteCount is zero
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper is closed.
jdo.extentcollection.constructor.invalidclass=JDO76022: Invalid class ''{0}'' for extent collection.
jdo.extentcollection.constructor.nonpc=JDO76023: The class ''{0}'' is not persistence-capable.
jdo.extentcollection.constructor.subclasses=JDO76024: Option subclasses true is not supported for extent collections.
jdo.extentcollection.illegalmodification=JDO76025: Illegal modification of extent collection for class ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: Extent collection method {0} not supported.
jdo.lifecycle.xactnotactive=JDO76027: Active transaction required to perform this operation.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: StateManager is not fully configured!
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: Attempt to replace not null javax.transaction.Transaction: {0} with {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: PersistenceManager for this javax.transaction.Transaction: {0} is already closed or committing.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: This instance of javax.transaction.Transaction: {0} is already registered with another PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: The version consistent instance failed the verification with the data store.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager is not configured.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), old state = {0}, new state = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), initial state = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} going to wait.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} acquired shared lock with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} going to wait.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: Closed for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() error: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Loading ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Loading ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Replacing deleted instance with new for Object Id: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() error: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() found javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() not found JDO Transaction.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is closed for: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: The column descriptor did not have a valid table descriptor.
core.configuration.fieldnotable=JDO76101: The field {0} is not associated with any table.
core.configuration.fieldnotmapped=JDO76102: The persistent field {0} for the class {1} is not mapped.
core.configuration.iddescnofield=JDO76103: The SqlIDDesc object was not set up properly.  There are no field descriptors available.
core.configuration.loadfailed.class=JDO76104: Failed to load the configuration for class {0}.
core.configuration.noneexistentpkfield=JDO76105: The field {0} in the ObjectId class {1} does not exist in the PersistenceCapable class {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: The class {0} has an unsupported consistency level. Currently supported consistency levels are "none", "check-modified-at-commit", "lock-when-loaded", and "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107: The mapping for class {0} is invalid:\n{1}.
core.configuration.validationproblem=JDO76108: Validation error in class {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: Value: {0} is less than minimum allowed: {1} for the field type {2}.
core.fielddesc.maxvalue=JDO76110: Value: {0} is greater than maximum allowed: {1} for the field type {2}.
core.configuration.noneexistentvcfield=JDO76111: The field {0} is marked as version field but does not exist in the PersistenceCapable class {1}.
core.configuration.loadfailed.field=JDO76112: Failed to load the configuration for field {0} in class {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=associated relationship field = {0}.
sqlstore.model.classdesc.createsqldesc=creating SqlIDDesc from {0}.
sqlstore.model.classdesc.fieldinfo=field name = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), class ={0} added hidden field {1}  for column {2}.
sqlstore.model.classdesc.loadedclass=Successfully loaded oid class= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), class = {0}.
sqlstore.model.classdesc.pkfield=PK field = {0}.
sqlstore.model.classdesc.primarytrackedfield=field {0} is the primary tracked field .
sqlstore.model.classdesc.unsetconcurrencychk=unsetting IN_CONCURRENCY_CHECK property for lf  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=unsetting REF_INTEGRITY_UPDATES property for ff {0}.
sqlstore.model.classdesc.vcfield=Version consistency field = {0}.
sqlstore.model.fielddesc.addingfield=adding field {0} to be tracked by field {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} From: {1} To: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: hidden {0} ... return.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... return.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} size before cleanup: {1}.
sqlstore.model.configcacheimpl.size_after={0} size after cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: Cannot assign SCO instance that is owned by another object.
core.statemanager.cantnewoid=JDO76201: Failed to create a new primary key instance of class {0}.
core.statemanager.cantschedulejointable=JDO76202: Failed to schedule the join table entry between class {0} and {1} because the relationship field description is null.
core.statemanager.cantsetkeyfield=JDO76203: Failed to set the value for the primary key field {0}.
core.statemanager.conflictingvalues=JDO76204: Conflicting values between field {0} and field {1} which are mapped to the same column
core.statemanager.getfieldfailed=JDO76205: Failed to get field.
core.statemanager.invalidpk=JDO76206: Invalid null primary key field {0} when reloading an instance of persistence capable class {1}. The ObjectId of the instance is {2}.
core.statemanager.nopkupdate=JDO76207: Update of a primary key field is not allowed.
core.statemanager.nopm=JDO76208: The state manager does not contain a reference to the persistence manager.
core.statemanager.notnavigable=JDO76209: An attempt was made to access the field {0} of the class {1}.  This field was not previously instantiated and this class does not allow dynamic navigation.  You must either request the field when retrieving the class or allow dynamic navigation so that it can be retrieved automatically when accessed.
core.statemanager.objectnotfound=JDO76210: Object does not exist in the data store.
core.statemanager.poshiddenindex=JDO76211: The index to a hidden field should be negative but we got an index of {0}.
core.statemanager.readonly=JDO76212: An attempt was made to modify the read-only field {0} of the class {1}.
core.statemanager.releaselock.wrongthread=JDO76213: This thread {0} does not hold StateManager lock.
core.statemanager.setfieldfailed=JDO76214: Failed to set field.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Incorrect attempt to remove an instance from a managed relationship. The relationship is defined by a primary key column on the other side. A remove operation on a collection requires updating the column on the other side, and primary key update is not allowed. Therefore, removal of an instance from a managed relationship collection defined by a primary key can only be done by deleting the instance, either explicitly or by cascade delete.
core.statemanager.toomanyrows=JDO76215: More than one row was returned for one of the tables mapped to the class {0}.  Each table mapped to a class should have only one row for each instance of the object.
core.statemanager.copyFields.mismatch=JDO76216: Attempt to copy fields from one StateManager to another which are managing instances of different types: {0} and {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), field = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), state manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired is : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=logging field = {0} with value = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), field = {0}.
sqlstore.sqlstatemanager.marking=marking: {0} as present.
sqlstore.sqlstatemanager.newtype=New Type: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : {0}  clone ... for type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), name = {0} for state: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, name = {0} for state: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=process foreign field ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), field realized = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.recordingfield=recording field = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, field = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Resetting Collection.
sqlstore.sqlstatemanager.resettingdate=Resetting Date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependency resolved: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), name = {0}.
sqlstore.sqlstatemanager.unsetmask=unsetting masks for field = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), name = {0}, value = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), name = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), immediate flush required: obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() skipped, type ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} value = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: The constraint is an \"order by\" for the field {0} which has already been specified in an \"order by\" constraint.
core.constraint.fielddisallowed=JDO76301: The fieldName parameter was specified, but it is disallowed with the operation {0}.
core.constraint.fieldrequired=JDO76302: The fieldName parameter is missing, but the operation {0} requires a field.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() for OP_PARAMETER must be called with value of type ParameterInfo.
core.constraint.illegalnode=JDO76304: Illegal constraint node {0} in the SqlConstraint stack.
core.constraint.illegalop=JDO76305: The operation parameter contained an illegal value of {0}.
core.constraint.needfieldnamenode=JDO76306: Error in the constraint stack. A field name is expected.
core.constraint.needfieldnode=JDO76307: Error in the constraint stack.  An field description is expected.
core.constraint.needvalnode=JDO76308: Error in the constraint stack.  A value is expected.
core.constraint.stackempty=JDO76309: The constraint stack is empty -- not enough values for the number of operator.
core.constraint.unknownfield=JDO76310: The field {0} specified in the retrieve descriptor is not a member of the class {1}.
core.constraint.valdisallowed=JDO76311: The value parameter was specified, but it is disallowed with the operation {0}.
core.constraint.valrequired=JDO76312: The value parameter is missing, but the operation {0} requires a value.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: Error while getting value from resultset at index {0} as resultType {1}. columnSqlType {2}. Exception: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: Queries for {0} should not have projections on a relationship field.
sqlstore.resultdesc.unknownfieldtype=JDO76317: Encountered unknown field type {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: Cannot set more than one projection for a RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: Cannot set more than one result type for a RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: One of the object types involved in this query is at consistency level "lock-when-loaded". Enforcing this consistency level requires data store to support locking for update at row level. The data store does not support locking for update at row level.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: LIKE ESCAPE clause is not supported on this database.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: Third arg for POSITION clause must be 1.
core.configuration.classnotmapped=JDO76323: The class {0} is not mapped.
core.configuration.classnotmappedtotable=JDO76324: The class {0} is not mapped to the table {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: A constraint for operation {0} can never be the root of a where clause.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=SQL statement
sqlstore.sql.generator.statement.withinputvalues= input values:
sqlstore.sql.generator.statement.withnoinputvalues= no input values.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializing = {0}.
sqlstore.resultdesc.marking_field=marking local field {0} as present.
sqlstore.resultdesc.marking_foreign_field=marking foreign field {0} as present.
sqlstore.resultdesc.marking_key_field=marking key field {0} as present.
sqlstore.resultdesc.returning_field=returning field {0} as projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} value: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executing {0} command(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), class = {0}, statements = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage is not set.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage is not set.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} is updated.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: Got a JDBC SQLException while executing the SQL statement:\n{0}.\nPlease examine the SQLException for more information.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: Unsupported multiple SQL statements for one RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: Fewer rows were returned from the database when attempting to get the value for the association {1} of the class {0} than the cardinality of this association allows.  The minimum number of rows allowed is {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: Database not consistent with persistent model.  An attempt to retrieve the object referred to by the {1} association of the {0} class retrieved {2} items, but only 1 item can be accommodated since the cardinality upper bound for the association is 1.
core.persistencestore.toomanyrows=JDO76405: More rows were returned from the database when attempting to get the value for the association {1} of the class {0} than the cardinality of this association allows.  The maximum number of rows allowed is {2}.
core.store.concurrentaccess=JDO76406: Concurrent access exception: object to {0} has been updated or deleted by another transaction.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: Error closing SQL result set. Exception: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: Error closing SQL statement. Exception: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: Unsupported multiple query plans for one RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; add batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; flush batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: vendor type = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: New ''{0}'' must be greater than or equal to current ''{1}''.
connection.connectionmanager.badvalue=JDO76501: Invalid value for ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: Connection timeout expired.
connection.connectionmanager.getconnection.mismatch=JDO76503: Pooled Connection does not have the same user context.
connection.connectionmanager.isdown=JDO76504: The Connection Manager is being shut down.
connection.connectionmanager.maxpool=JDO76505: Connection pool is at maximum.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval must be greater than zero and less than or equal to MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait must be greater than or equal to zero.
connection.connectionmanager.nulldriver=JDO76508: NULL value for Driver Name.
connection.connectionmanager.nullurl=JDO76509: NULL value for URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' must be greater than or equal to 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: Thread interrupted.
connection.connectionmanager.zero=JDO76512: ''{0}'' must be greater than or equal to zero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: Can not load properties for default database.
sqlstore.database.dbvendor.init.default=JDO76514: -->Could not load property for vendor type {0}. Defaults will be used.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: Failed to instantiate the class {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: Failed to define column for statement.
sqlstore.database.oracle.nooracleavailable=JDO76517: While initializing Oracle resource factory ''{0}'', failed to get an instance of either oracle.jdbc.OraclePreparedStatement or oracle.jdbc.driver.OraclePreparedStatement. Oracle specific optimization will be disabled. If instances that use this resource require binding values for columns mapped to Fixed Char column, the values will be padded with spaces to the length specified in the corresponding dbschema file.
sqlstore.database.oracle.fixedcharpadded=JDO76518: Value "{0}" is bound to a CHAR column. This requires special handling on Oracle. As the class  OraclePreparedStatement could not be obtained from the driver, the value is padded with spaces to the length {1} as specified in the captured dbschema file.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: Failed to identify vendor type for the data store.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: Errors while obtaining information about the database. Got the following exception:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: found {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: new {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: free {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connection closed .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connection released.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connection closed.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: put in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connection replaced.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connection closed.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connection closed.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connection closed.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} with: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: Method {0} should not be called in a non-managed environment.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: JNDI lookup for cmp-resource ''{0}'' failed.
JDO76604.diag.cause.1=CMP resource with this JNDI name is not registered with this instance.
JDO76604.diag.cause.2=JNDI name for the CMP resource is misspelled.
JDO76604.diag.check.1=Check JNDI name for the resource you plan to use.
JDO76604.diag.check.2=Check JNDI name of the CMP resource specified in the module.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: JNDI lookup for cmp-resource ''{0}'' returned an instance of an unexpected type: {1}.
JDO76605.diag.cause.1=CMP resource with this JNDI name does not reference jdbc-resource or persistence-manager-factory-resource.
JDO76605.diag.cause.2=JNDI name for the CMP resource is misspelled.
JDO76605.diag.check.1=Check JNDI name for the resource you plan to use.
JDO76605.diag.check.2=Check JNDI name of the CMP resource specified in the module.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Getting connection for JNDI name ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: Invalid access of CMPHelper. This class is used for CMP support only and should not be called outside an application server.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: DataSource is not of the expected type. Expected: com.sun.appserv.jdbc.DataSource got: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=The field {0} is not a member of the class {1}.
core.generic.unknownexception=Got an unknown exception.
core.generic.nullparam=The {0} parameter is null.
core.generic.notinstanceof=The object of class {0} is not an instance of {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Failed to load the class {0}.
sqlstore.exception.log=Exception.
jdo.lifecycle.deleted.accessField=Cannot access field of a deleted instance.
