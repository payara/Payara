#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2013 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: N\u00E3o \u00E9 poss\u00EDvel utilizar m\u00FAltiplas combina\u00E7\u00F5es de nome de usu\u00E1rio/senha na mesma transa\u00E7\u00E3o.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: O PersistenceManagerFactory n\u00E3o est\u00E1 configurado.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: A opera\u00E7\u00E3o n\u00E3o possui suporte para o PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: Falha ao adquirir o bloqueio exclusivo devido a InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: Falha ao adquirir o bloqueio compartilhado porque _readWriteCount \u00E9 menor que zero.
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: Falha ao adquirir o bloqueio compartilhado devido a InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: O objeto est\u00E1 associado a outro PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: A transa\u00E7\u00E3o associada a esse gerenciador de persist\u00EAncia n\u00E3o est\u00E1 ativa.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: O PersistenceManager est\u00E1 fechado.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: A classe {0} n\u00E3o foi aprimorada para a persist\u00EAncia transparente. Utilize o JAR do IDE ou o encapsulador WAR para encapsular suas classes com capacidade de persist\u00EAncia antes de executar. Ou, defina a propriedade Executor na classe principal como Executor da persist\u00EAncia a ser executado a partir do IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: H\u00E1 uma transa\u00E7\u00E3o aberta associada a esse gerenciador de persist\u00EAncia.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: O objeto n\u00E3o \u00E9 encontrado para este ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: N\u00E3o \u00E9 poss\u00EDvel deletar um objeto n\u00E3o-persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: Uma inst\u00E2ncia com a mesma chave prim\u00E1ria j\u00E1 existe no cache PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: Erro ao recuperar a classe do objeto do OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: N\u00E3o \u00E9 poss\u00EDvel criar a inst\u00E2ncia SCO da classe {0} por n\u00E3o ser de um tipo v\u00E1lido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: N\u00E3o \u00E9 poss\u00EDvel descarregar inst\u00E2ncias de persist\u00EAncia por causa de depend\u00EAncias circulares.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: Falha ao liberar o bloqueio compartilhado porque _readWriteCount \u00E9 maior que zero.
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: Falha ao liberar o bloqueio compartilhado porque _readWriteCount \u00E9 zero.
jdo.persistencemanagerwrapper.invalidpm=JDO76021: O PersistenceManagerWrapper est\u00E1 fechado.
jdo.extentcollection.constructor.invalidclass=JDO76022: Classe inv\u00E1lida "{0}" para o conjunto de extens\u00E3o.
jdo.extentcollection.constructor.nonpc=JDO76023: A classe "{0}" n\u00E3o \u00E9 de capacidade de persit\u00EAncia.
jdo.extentcollection.constructor.subclasses=JDO76024: As subclasses de op\u00E7\u00E3o verdadeiras n\u00E3o possuem suporte para conjuntos de extens\u00F5es.
jdo.extentcollection.illegalmodification=JDO76025: Modifica\u00E7\u00E3o ilegal do conjunto de extens\u00E3o para a classe "{0}".
jdo.extentcollection.methodnotsupported=JDO76026: O m\u00E9todo {0} de conjunto de extens\u00E3o n\u00E3o possui suporte.
jdo.lifecycle.xactnotactive=JDO76027: A transa\u00E7\u00E3o ativa necess\u00E1ria para executar esta opera\u00E7\u00E3o.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: O StateManager n\u00E3o est\u00E1 totalmente configurado!
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: Tentativa de substituir javax.transaction.Transaction n\u00E3o-nula: {0} por {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: O PersistenceManager para essa javax.transaction.Transaction: {0} j\u00E1 est\u00E1 fechado ou est\u00E1 sendo confirmado.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: Esta inst\u00E2ncia do javax.transaction.Transaction: {0} j\u00E1 est\u00E1 registrada com outro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: Falha da verifica\u00E7\u00E3o com o armazenador de dados pela inst\u00E2ncia de consist\u00EAncia da vers\u00E3o.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: O StoreManager n\u00E3o est\u00E1 configurado.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), estado antigo = {0}, novo estado = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), estado inicial = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} vai aguardar.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} adquiriu o bloqueio compartilhado with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} vai aguardar.
sqlstore.persistencemgr.aftercompletion.process=Processar ---PersistenceManagerImpl.afterCompletion(): {0}.
sqlstore.persistencemgr.aftercompletion=Abortar ---PersistenceManagerImpl.afterCompletion(): {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Encerrado para  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen:  Encerrado para  {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=Propriedades do cache PersistenceManagerImpl: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- registro cancelado com verifica\u00E7\u00E3o.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() com SM de verifica\u00E7\u00E3o -- oid: {0}  para PersistenceManager: {1}  e JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  para PersistenceManager: {1}  e JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  para PersistenceManager: {1} e JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > atual: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() N\u00C3O PC: {0}  para PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() N\u00C3O PM: {0} para PersistenceManager: {1}  e JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} para PersistenceManager: {2} e JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): antigo: {0}  novo: {1} o mesmo: {2}.
sqlstore.persistencemgr.internalcloneoid=Erro de ---PersistenceManagerImpl.internalCloneOid(): {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Carregando ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Carregando ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finalizado para: {1}  e JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} para PersistenceManager: {2} e JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() tipo: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > atual: {0}  anterior: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > atual: {0}  novo: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  para PersistenceManager: {3}  e JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} para PersistenceManager: {2} e JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance em WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Substituindo inst\u00E2ncia deletada por uma novo para o Id do Objeto: {0}.
sqlstore.persistencemgr.setkeyfields=Erro de ---PersistenceManagerImpl.setKeyFields(): {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} para JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() javax.transaction encontrada.Transa\u00E7\u00E3o: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() Transa\u00E7\u00E3o JDO n\u00E3o encontrada.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() Transa\u00E7\u00E3o JDO: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM est\u00E1 encerrada para: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} para JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} para JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} para JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: O descritor da coluna n\u00E3o tinha um descritor de tabela v\u00E1lido.
core.configuration.fieldnotable=JDO76101: O campo {0} n\u00E3o est\u00E1 associado a qualquer tabela.
core.configuration.fieldnotmapped=JDO76102: O campo de persist\u00EAncia {0} para a classe {1} n\u00E3o est\u00E1 mapeado.
core.configuration.iddescnofield=JDO76103: O objeto SqlIDDesc n\u00E3o foi corretamente configurado. N\u00E3o h\u00E1 descritores de campo dispon\u00EDveis.
core.configuration.loadfailed.class=JDO76104: Falha ao carregar a configura\u00E7\u00E3o para a classe {0}.
core.configuration.noneexistentpkfield=JDO76105: O campo {0} na classe ObjectId {1} n\u00E3o existe na classe PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: A classe {0} tem um n\u00EDvel de consist\u00EAncia n\u00E3o suportado. Os n\u00EDveis de consist\u00EAncia no momento suportados s\u00E3o "nenhum", "verificar modificado ao confirmar", "bloquear quando carregado" e "verificar vers\u00E3o de inst\u00E2ncias acessadas".
core.configuration.validationfailed=JDO76107: O mapeamento para a classe {0} \u00E9 inv\u00E1lido:\n{1}.
core.configuration.validationproblem=JDO76108: Erro de valida\u00E7\u00E3o na classe {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: Valor: {0} \u00E9 menor do que o m\u00EDnimo permitido: {1} para o tipo de campo {2}.
core.fielddesc.maxvalue=JDO76110: Valor: {0} \u00E9 maior do que o m\u00E1ximo permitido: {1} para o tipo de campo {2}.
core.configuration.noneexistentvcfield=JDO76111: O campo {0} est\u00E1 marcado como campo de vers\u00E3o, mas n\u00E3o existe na classe PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: Falha ao carregar a configura\u00E7\u00E3o para o campo {0} na classe {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=campo de relacionamento associado = {0}.
sqlstore.model.classdesc.createsqldesc=criando SqlIDDesc de {0}.
sqlstore.model.classdesc.fieldinfo=nome do campo = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), classe ={0} adicionada ao campo oculto {1}  da coluna {2}.
sqlstore.model.classdesc.loadedclass=oid class= {0} carregada com sucesso.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), classe = {0}.
sqlstore.model.classdesc.pkfield=Campo de Chave Prim\u00E1ria = {0}.
sqlstore.model.classdesc.primarytrackedfield=o campo {0} \u00E9 o campo prim\u00E1rio rastreado .
sqlstore.model.classdesc.unsetconcurrencychk=propriedade n\u00E3o definida IN_CONCURRENCY_CHECK para  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=propriedade n\u00E3o definida REF_INTEGRITY_UPDATES para ff {0}.
sqlstore.model.classdesc.vcfield=Vers\u00E3o campo de consist\u00EAncia = {0}.
sqlstore.model.fielddesc.addingfield=adicionando o campo {0} para ser rastreado pelo campo {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} De: {1} Para: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: oculto {0} ... retornar.
sqlstore.model.fielddesc.convertvalue=convertValue: NULO ... retornar.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before=tamanho {0} antes de limpar: {1}.
sqlstore.model.configcacheimpl.size_after=tamanho {0} depois de limpar: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: N\u00E3o \u00E9 poss\u00EDvel designar a inst\u00E2ncia SCO que \u00E9 de propriedade de outro objeto.
core.statemanager.cantnewoid=JDO76201: Falha em criar uma nova inst\u00E2ncia de chave prim\u00E1ria da classe {0}.
core.statemanager.cantschedulejointable=JDO76202: Falha em programar a entrada de tabela de jun\u00E7\u00E3o entre a classe {0} e {1} porque a descri\u00E7\u00E3o do campo de relacionamento \u00E9 nula.
core.statemanager.cantsetkeyfield=JDO76203: Falha ao definir o valor para o campo de chave prim\u00E1ria {0}.
core.statemanager.conflictingvalues=JDO76204: Valores conflitantes entre o campo {0} e o campo {1} que est\u00E3o mapeados para a mesma coluna
core.statemanager.getfieldfailed=JDO76205: Falha ao obter o campo.
core.statemanager.invalidpk=JDO76206: Campo de chave prim\u00E1ria nula inv\u00E1lido {0} ao recarregar uma inst\u00E2ncia de classe com capacidade de persist\u00EAncia {1}. O ObjectId da inst\u00E2ncia \u00E9 {2}.
core.statemanager.nopkupdate=JDO76207: A atualiza\u00E7\u00E3o do campo de uma chave prim\u00E1ria n\u00E3o \u00E9 permitida.
core.statemanager.nopm=JDO76208: O gerenciador de estado n\u00E3o cont\u00E9m uma refer\u00EAncia para o gerenciador de persist\u00EAncia.
core.statemanager.notnavigable=JDO76209: Foi feita uma tentativa de acessar o campo {0} da classe {1}. Esse campo n\u00E3o foi anteriormente instanciado e essa classe n\u00E3o permite a navega\u00E7\u00E3o din\u00E2mica. \u00C9 preciso solicitar o campo ao recuperar a classe ou permitir a navega\u00E7\u00E3o din\u00E2mica para que ele possa ser automaticamente recuperado quando acessado.
core.statemanager.objectnotfound=JDO76210: O objeto n\u00E3o existe no armazenamento de dados.
core.statemanager.poshiddenindex=JDO76211: O \u00EDndice para um campo oculto deveria ser negativo, mas foi obtido um \u00EDndice de {0}.
core.statemanager.readonly=JDO76212: Foi feita uma tentativa de modificar um campo somente para leitura {0} da classe {1}.
core.statemanager.releaselock.wrongthread=JDO76213: Este thread {0} n\u00E3o armazena o bloqueio do StateManager.
core.statemanager.setfieldfailed=JDO76214: Falha ao definir o campo.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Tentativa incorreta de remover uma inst\u00E2ncia de um relacionamento gerenciado. O relacionamento \u00E9 definido por uma coluna de chave prim\u00E1ria no outro lado. Uma opera\u00E7\u00E3o de remo\u00E7\u00E3o em um conjunto requer a atualiza\u00E7\u00E3o da coluna no outro lado e a atualiza\u00E7\u00E3o da chave prim\u00E1ria n\u00E3o \u00E9 permitida. Portanto, a remo\u00E7\u00E3o de uma inst\u00E2ncia de um conjunto de relacionamento gerenciado definida por uma chave prim\u00E1ria pode ser feita somente ao deletar a inst\u00E2ncia, explicitamente ou por dele\u00E7\u00E3o em cascata.
core.statemanager.toomanyrows=JDO76215: Mais de uma linha foi retornada para uma das tabelas mapeadas a classe {0}. Cada tabela mapeada a uma classe deveria ter somente uma linha para cada inst\u00E2ncia do objeto.
core.statemanager.copyFields.mismatch=JDO76216: Tentativa de copiar campos de um StateManager para outro, que est\u00E3o gerenciando inst\u00E2ncias de diferentes tipos: {0} e {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), este StateManager: {0}, outro StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), campo = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), gerenciador de estado = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), tipo = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired \u00E9 : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=campo de log = {0} com o valor = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), campo = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Campo bruto marcado = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), tipo = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), campo = {0}.
sqlstore.sqlstatemanager.marking=marcando: {0} como presente.
sqlstore.sqlstatemanager.newtype=Novo Tipo: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exce\u00E7\u00E3o : {0}  clone ... para o tipo {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), nome = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), nome = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), tipo = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), tipo = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), nome = {0} para o estado: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, nome = {0} para o estado: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=processar campo estrangeiro ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): era Conjunto - remover.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remover do BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - redefinir.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): valor: {0} tipo: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), nome = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), campo realizado = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), nome = {0}.
sqlstore.sqlstatemanager.recordingfield=campo de grava\u00E7\u00E3o = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), tipo = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), tipo = {0}, campo = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), n\u00E3o definir SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), campo = {0}, tipo= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Redefinindo Conjunto.
sqlstore.sqlstatemanager.resettingdate=Redefinindo Data.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), depend\u00EAncia resolvida: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), nome = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), nome = {0}.
sqlstore.sqlstatemanager.unsetmask=n\u00E3o definindo m\u00E1scaras para o campo = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), tipo = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), nome = {0}, valor = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), nome = {0}, tipo = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), descarregamento imediato exigido: obj={0}, pr\u00F3ximo={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() ignorado, tipo ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), tipo = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} valor = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: A restri\u00E7\u00E3o \u00E9 um "ordenar por" para o campo {0} que j\u00E1 foi especificado em uma restri\u00E7\u00E3o "ordenar por".
core.constraint.fielddisallowed=JDO76301: O par\u00E2metro fieldName foi especificado, mas n\u00E3o \u00E9 permitido com a opera\u00E7\u00E3o {0}.
core.constraint.fieldrequired=JDO76302: O par\u00E2metro fieldName est\u00E1 ausente, mas a opera\u00E7\u00E3o {0} exige um campo.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() para OP_PARAMETER precisa ser chamado com valor do tipo ParameterInfo.
core.constraint.illegalnode=JDO76304: N\u00F3 ilegal de restri\u00E7\u00E3o {0} na pilha SqlConstraint.
core.constraint.illegalop=JDO76305: O par\u00E2metro da opera\u00E7\u00E3o continha um valor ilegal de {0}.
core.constraint.needfieldnamenode=JDO76306: Erro na pilha de restri\u00E7\u00E3o. Um nome de campo \u00E9 esperado.
core.constraint.needfieldnode=JDO76307: Erro na pilha de restri\u00E7\u00E3o. Uma descri\u00E7\u00E3o de campo \u00E9 esperada.
core.constraint.needvalnode=JDO76308: Erro na pilha de restri\u00E7\u00E3o. Um valor \u00E9 esperado.
core.constraint.stackempty=JDO76309: A pilha de restri\u00E7\u00E3o est\u00E1 vazia -- valores insuficientes para o n\u00FAmero do operador.
core.constraint.unknownfield=JDO76310: O campo {0} especificado no descritor de recupera\u00E7\u00E3o n\u00E3o \u00E9 um membro da classe {1}.
core.constraint.valdisallowed=JDO76311: O par\u00E2metro de valor foi especificado, mas n\u00E3o \u00E9 permitido com a opera\u00E7\u00E3o {0}.
core.constraint.valrequired=JDO76312: O par\u00E2metro de valor est\u00E1 ausente, mas a opera\u00E7\u00E3o {0} exige um valor.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: Erro ao obter o valor do resultset no \u00EDndice {0} como resultType {1}. columnSqlType {2}. Exce\u00E7\u00E3o: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: As consultas para {0} n\u00E3o deveriam ter proje\u00E7\u00F5es em um campo de relacionamento.
sqlstore.resultdesc.unknownfieldtype=JDO76317: Um tipo desconhecido de campo foi encontrado {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: N\u00E3o \u00E9 poss\u00EDvel definir mais de uma proje\u00E7\u00E3o para um RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: N\u00E3o \u00E9 poss\u00EDvel definir mais de um tipo de resultado para um RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: Um dos tipos de objetos envolvidos nesta consulta est\u00E1 no n\u00EDvel de consist\u00EAncia "bloquear quando carregado". For\u00E7ar este n\u00EDvel de consist\u00EAncia requer que o armazenador de dados suporte o bloqueio para atualizar no n\u00EDvel da linha. O armazenador de dados n\u00E3o suporta o bloqueio para atualizar no n\u00EDvel da linha.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: A cl\u00E1usula LIKE ESCAPE n\u00E3o possui suporte neste banco de dados.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: Terceiro arg para a cl\u00E1usula POSITION deve ser 1.
core.configuration.classnotmapped=JDO76323: A classe "{0}" n\u00E3o est\u00E1 mapeada.
core.configuration.classnotmappedtotable=JDO76324: A classe {0} n\u00E3o est\u00E1 mapeada para a tabela {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: Uma restri\u00E7\u00E3o para a opera\u00E7\u00E3o {0} nunca pode ser a raiz de uma cl\u00E1usula Where.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Instru\u00E7\u00E3o SQL
sqlstore.sql.generator.statement.withinputvalues= valores de entrada:
sqlstore.sql.generator.statement.withnoinputvalues= sem valores de entrada.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=desserializando = {0}.
sqlstore.resultdesc.marking_field=marcando campo local {0} como presente.
sqlstore.resultdesc.marking_foreign_field=marcando campo estrangeiro {0} como presente.
sqlstore.resultdesc.marking_key_field=marcando campo chave {0} como presente.
sqlstore.resultdesc.returning_field=retornando campo {0} como proje\u00E7\u00E3o.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), transa\u00E7\u00E3o resumida = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), transa\u00E7\u00E3o suspensa = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} valor: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executando {0} comando(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), classe = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), classe = {0}, instru\u00E7\u00F5es = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage n\u00E3o est\u00E1 definido.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage n\u00E3o est\u00E1 definido.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} foi atualizado.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: Obteve um JDBC SQLException ao executar a instru\u00E7\u00E3o SQL:\n{0}.\nExamine a SQLException para obter mais informa\u00E7\u00F5es.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: M\u00FAltiplas instru\u00E7\u00F5es SQL n\u00E3o possuem suporte para um RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: Menos linhas foram retornadas do banco de dados ao tentar obter o valor para a associa\u00E7\u00E3o {1} da classe {0} do que permite a cardinalidade desta associa\u00E7\u00E3o. O n\u00FAmero m\u00EDnimo de linhas permitido \u00E9 de {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: O banco de dados n\u00E3o \u00E9 consistente com o modelo persistente. Uma tentativa de recuperar o objeto referenciado pela {1} associa\u00E7\u00E3o de itens da {0} classe recuperada {2} , mas somente 1 item pode ser acomodado j\u00E1 que o limite superior da cardinalidade para a associa\u00E7\u00E3o \u00E9 1.
core.persistencestore.toomanyrows=JDO76405: Mais linhas foram retornadas do banco de dados ao tentarem obter o valor para a associa\u00E7\u00E3o {1} da classe {0} do que permite a cardinalidade desta associa\u00E7\u00E3o. O n\u00FAmero m\u00E1ximo linhas permitido \u00E9 {2}.
core.store.concurrentaccess=JDO76406: Exce\u00E7\u00E3o de acesso concorrente: o objeto para {0} foi atualizado ou deletado por outra transa\u00E7\u00E3o.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: Erro ao fechar o conjunto de resultados SQL. Exce\u00E7\u00E3o : {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: Erro ao fechar a instru\u00E7\u00E3o SQL. Exce\u00E7\u00E3o : {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: V\u00E1rios planos de consulta n\u00E3o suportados suporte para um RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), linhas afetadas = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; adicionar batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), linhas afetadas = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; descarregar batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: tipo fornecedor = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: Novo "{0}" precisa ser maior ou igual ao atual "{1}".
connection.connectionmanager.badvalue=JDO76501: Valor inv\u00E1lido para "{0}".
connection.connectionmanager.conntimeout=JDO76502: Tempo de time-out expirado.
connection.connectionmanager.getconnection.mismatch=JDO76503: A conex\u00E3o agrupada n\u00E3o tem o mesmo contexto de usu\u00E1rio.
connection.connectionmanager.isdown=JDO76504: Shutdown do Gerenciador de Conex\u00F5es em andamento.
connection.connectionmanager.maxpool=JDO76505: O pool de conex\u00F5es est\u00E1 no m\u00E1ximo.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval precisa ser maior que zero e menor ou igual a MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait precisa ser maior ou igual a zero.
connection.connectionmanager.nulldriver=JDO76508: Valor NULO para o Nome do Driver.
connection.connectionmanager.nullurl=JDO76509: Valor NULO para o URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' precisa ser maior ou igual a 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: Thread interrompido.
connection.connectionmanager.zero=JDO76512: "{0}" precisa ser maior ou igual a zero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: N\u00E3o \u00E9 poss\u00EDvel carregar as propriedades para o banco de dados default.
sqlstore.database.dbvendor.init.default=JDO76514: -->N\u00E3o foi poss\u00EDvel carregar a propriedade para o tipo de fornecedor {0}. Os defaults ser\u00E3o utilizados.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: Falha ao instanciar a classe {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: Falha ao definir a coluna para a instru\u00E7\u00E3o.
sqlstore.database.oracle.nooracleavailable=JDO76517: Ao inicializar a f\u00E1brica de recursos Oracle "{0}", houve uma falha em obter uma inst\u00E2ncia do oracle.jdbc.OraclePreparedStatement ou do oracle.jdbc.driver.OraclePreparedStatement. A otimiza\u00E7\u00E3o espec\u00EDfica do Oracle ser\u00E1 desativada. Se as inst\u00E2ncias que utilizam este recurso necessitam de valores vincul\u00E1veis para colunas mapeadas para a coluna Fixed Char, os valores ser\u00E3o preenchidos com espa\u00E7os at\u00E9 o tamanho especificado no arquivo dbschema correspondente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: O valor "{0}" est\u00E1 vinculado a uma coluna CHAR. Isso requer o manuseio especial no Oracle. Como n\u00E3o foi poss\u00EDvel obter a classe OraclePreparedStatement no driver, o valor \u00E9 preenchido com espa\u00E7os at\u00E9 o tamanho {1}, conforme especificado no arquivo dbschema capturado.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: Falha em identificar o tipo de fornecedor para o armazenador de dados.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: Ocorreram erros ao obter informa\u00E7\u00F5es sobre o banco de dados. Obteve a seguinte exce\u00E7\u00E3o:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: encontrado {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: novo {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: livro {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: conex\u00E3o encerrada .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: conex\u00E3o liberada.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: conex\u00E3o encerrada.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: FreePending definido.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: colocado na freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: conex\u00E3o substitu\u00EDda.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: conex\u00E3o encerrada.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: conex\u00E3o encerrada.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: disassociateXact pendente.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: conex\u00E3o encerrada.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} com: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NENHUM.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} para  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} para  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} para {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX otimista: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX otimista: {0} Confirma\u00E7\u00E3o Interna: {1} referenceCount: {2} para {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} para {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} para {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: O m\u00E9todo {0} n\u00E3o deveria ser chamado em um ambiente n\u00E3o-gerenciado.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: Falha da pesquisa JNDI para cmp-resource "{0}".
JDO76604.diag.cause.1=O recurso CMP junto a este nome JNDI n\u00E3o est\u00E1 registrado com essa inst\u00E2ncia.
JDO76604.diag.cause.2=O nome JNDI para o recurso CMP tem erro de ortografia.
JDO76604.diag.check.1=Verifique o nome JNDI para o recurso que planeja utilizar.
JDO76604.diag.check.2=Verifique o nome JNDI do recurso CMP especificado no m\u00F3dulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: A pesquisa JNDI para o cmp-resource "{0}" retornou uma inst\u00E2ncia de tipo inesperado: {1}.
JDO76605.diag.cause.1=O recurso CMP com este nome JNDI n\u00E3o faz refer\u00EAncia ao jdbc-resource ou o persistence-manager-factory-resource.
JDO76605.diag.cause.2=O nome JNDI para o recurso CMP tem erro de ortografia.
JDO76605.diag.check.1=Verifique o nome JNDI para o recurso que planeja utilizar.
JDO76605.diag.check.2=Verifique o nome JNDI do recurso CMP especificado no m\u00F3dulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Obtendo conex\u00E3o para o nome JNDI ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: Acesso inv\u00E1lido do CMPHelper. Esta classe \u00E9 usada somente para o suporte CMP e n\u00E3o deveria ser chamada fora de um servidor de aplica\u00E7\u00F5es.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: O DataSource n\u00E3o \u00E9 do tipo esperado. Esperado: com.sun.appserv.jdbc.DataSource, obteve: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=O campo {0} n\u00E3o \u00E9 um membro da classe {1}.
core.generic.unknownexception=Ocorreu uma exce\u00E7\u00E3o desconhecida.
core.generic.nullparam=O par\u00E2metro {0} \u00E9 nulo.
core.generic.notinstanceof=O objeto de classe {0} n\u00E3o \u00E9 uma inst\u00E2ncia de {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Falha ao carregar a classe {0}.
sqlstore.exception.log=Exce\u00E7\u00E3o.
jdo.lifecycle.deleted.accessField=N\u00E3o \u00E9 poss\u00EDvel acessar o campo de uma inst\u00E2ncia deletada.
