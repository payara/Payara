#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2013 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: In einer Transaktion k\u00F6nnen nicht mehrere Kombinationen von Benutzername/Kennwort verwendet werden.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory ist nicht konfiguriert.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: Vorgang wird f\u00FCr interne PersistenceManagerFactoryImpl nicht unterst\u00FCtzt
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: Exklusive Sperre konnte aufgrund einer InterruptedException nicht erworben werden
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: Sperre im SHARE-Modus konnte nicht angefordert werden, da _readWriteCount kleiner als null ist
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: Sperre im SHARE-Modus konnte aufgrund einer InterruptedException nicht angefordert werden
jdo.persistencemanagerimpl.another_pm=JDO76006: Objekt ist mit anderem PersistenceManager verbunden.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: Die mit diesem Persistence Manager verbundene Transaktion ist nicht aktiv.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: PersistenceManager ist geschlossen.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: Klasse {0} wurde nicht f\u00FCr Transparent Persistence erweitert. Verwenden Sie einen .ide-, .jar- oder .war-Packager zum Verpacken Ihrer persistenzf\u00E4higen Klassen vor dem Ausf\u00FChren. Oder setzen Sie die Executor-Eigenschaft auf der Hauptklasse auf ''Persistence Executor'' f\u00FCr das Ausf\u00FChren aus IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: Es liegt eine offene Transaktion in Verbindung mit diesem Persistence Manager vor.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: Kein Objekt f\u00FCr diese ObjectId gefunden.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: Nicht dauerhaftes Objekt kann nicht gel\u00F6scht werden.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: Eine Instanz mit demselben Prim\u00E4rschl\u00FCssel existiert bereits in diesem PersistenceManager-Cache.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: Fehler beim Abrufen der Objektklasse aus OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: SCO-Instanz der Klasse {0} kann nicht erstellt werden, dass es sich nicht um einen g\u00FCltigen Typ handelt.
jdo.persistencemanagerimpl.notprocessed=JDO76018: Persistente Instanzen konnten aufgrund von zyklischen Abh\u00E4ngigkeiten nicht zur\u00FCckgesetzt werden.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: Exklusive Sperre konnte nicht freigegeben werden, da _readWriteCount gr\u00F6\u00DFer als null ist
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: Sperre im SHARE-Modus konnte nicht freigegeben werden, da _readWriteCount null ist
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper ist geschlossen.
jdo.extentcollection.constructor.invalidclass=JDO76022: Ung\u00FCltige Klasse ''{0}'' f\u00FCr Extent Collection.
jdo.extentcollection.constructor.nonpc=JDO76023: Die Klasse ''{0}'' ist nicht persistenzf\u00E4hig.
jdo.extentcollection.constructor.subclasses=JDO76024: Die True-Option f\u00FCr Unterklassen wird f\u00FCr Extent Collections nicht unterst\u00FCtzt.
jdo.extentcollection.illegalmodification=JDO76025: Unzul\u00E4ssige \u00C4nderung der Extent Collection f\u00FCr Klasse ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: Extent Collection-Methode {0} wird nicht unterst\u00FCtzt.
jdo.lifecycle.xactnotactive=JDO76027: Aktive Transaktion f\u00FCr die Durchf\u00FChrung dieses Vorgangs erforderlich.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: StateManager ist nicht vollst\u00E4ndig konfiguriert.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: Es wurde versucht, Nicht-Null-javax.transaction.Transaction zu ersetzen: {0} mit {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: PersistenceManager f\u00FCr diese javax.transaction.Transaction: {0} ist bereits geschlossen oder wird durchgef\u00FChrt.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: Diese Instanz von javax.transaction.Transaction: {0} ist bereits bei einem anderen PersistenceManager registriert: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: Die versionskonsistente Instanz hat die \u00DCberpr\u00FCfung mit dem Datenspeicher nicht bestanden.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager ist nicht konfiguriert.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), alter Status = {0}, neuer Status = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), Ursprungsstatus = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), Thread {0} mit _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), Thread {0} muss warten.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), Thread {0} hat freigegebene Sperre mit _readWriteCount ={1} angefordert.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), Thread {0} muss warten.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion()-Prozess: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() Abbruch: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Geschlossen f\u00FCr {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction: {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: Geschlossen f\u00FCr {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- Registrierung mit "verify" aufgehoben.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() mit "verify SM" -- oid: {0} f\u00FCr PersistenceManager: {1} und JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0} f\u00FCr PersistenceManager: {1} und JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0} f\u00FCr PersistenceManager: {1} und JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > aktuell: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0} f\u00FCr PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} f\u00FCr PersistenceManager: {1} und JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} f\u00FCr PersistenceManager: {2} und JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): alt: {0} neu: {1} identisch: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid()-Fehler: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction(): {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead(): {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction(): {0}.
sqlstore.persistencemgr.loadingclass=Wird geladen ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Wird geladen ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0} beendet f\u00FCr: {1} und JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} f\u00FCr PersistenceManager: {2} und JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > aktuell: {0} vorher: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > aktuell: {0} neu: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2} f\u00FCr PersistenceManager: {3} und JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC: {0} / {1} f\u00FCr PersistenceManager: {2} und JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), Thread {0} mit _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), Thread {0} mit _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Gel\u00F6schte Instanz wird durch neue Instanz f\u00FCr Objekt-ID ersetzt: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields()-Fehler: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} f\u00FCr JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() hat javax.transaction gefunden. Transaktion: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() hat keine JDO-Transaktion gefunden.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO-Transaktion: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM ist geschlossen f\u00FCr: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager(): {1} f\u00FCr JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} f\u00FCr JTA-Transaktion: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} f\u00FCr JTA-Transaktion: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: Der Spaltendeskriptor verf\u00FCgt \u00FCber keinen g\u00FCltigen Tabellendeskriptor.
core.configuration.fieldnotable=JDO76101: Das Feld {0} ist mit keiner Tabelle verbunden.
core.configuration.fieldnotmapped=JDO76102: Das persistente Feld {0} f\u00FCr die Klasse {1} ist nicht zugeordnet.
core.configuration.iddescnofield=JDO76103: Das SqlIDDesc-Objekt wurde nicht ordnungsgem\u00E4\u00DF eingerichtet. Es sind keine Feldbeschreibungen verf\u00FCgbar.
core.configuration.loadfailed.class=JDO76104: Die Konfiguration f\u00FCr die Klasse {0} konnte nicht geladen werden.
core.configuration.noneexistentpkfield=JDO76105: Das Feld {0} in der ObjectId-Klasse {1} existiert nicht in der PersistenceCapable-Klasse {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: Die Klasse {0} weist eine nicht unterst\u00FCtzte Konsistenzebene auf. Die derzeit unterst\u00FCtzten Konsistenzebenen lauten "keine", "\u00C4nderung bei Durchf\u00FChrung \u00FCberpr\u00FCfen", "Bei Laden sperren" und "Version von verwendeten Instanzen \u00FCberpr\u00FCfen".
core.configuration.validationfailed=JDO76107: Die Zuordnung f\u00FCr Klasse {0} ist ung\u00FCltig:\n{1}.
core.configuration.validationproblem=JDO76108: \u00DCberpr\u00FCfungsfehler in Klasse {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: Wert: {0} ist niedriger als zul\u00E4ssiges Minimum: {1} f\u00FCr Feldtyp {2}.
core.fielddesc.maxvalue=JDO76110: Wert: {0} ist gr\u00F6\u00DFer als zul\u00E4ssiges Maximum: {1} f\u00FCr Feldtyp {2}.
core.configuration.noneexistentvcfield=JDO76111: Das Feld {0} ist als Versionsfeld markiert, existiert jedoch in der PersistenceCapable-Klasse {1} nicht.
core.configuration.loadfailed.field=JDO76112: Die Konfiguration f\u00FCr Feld {0} in Klasse {1} konnte nicht geladen werden.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=verkn\u00FCpftes Beziehungsfeld = {0}.
sqlstore.model.classdesc.createsqldesc=SqlIDDesc wird aus {0} erstellt.
sqlstore.model.classdesc.fieldinfo=Feldname = {0}, ID= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), Klasse ={0} ausgeblendetes Feld {1} f\u00FCr Spalte {2} hinzugef\u00FCgt.
sqlstore.model.classdesc.loadedclass=OID-Klasse erfolgreich geladen= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), Klasse = {0}.
sqlstore.model.classdesc.pkfield=PK-Feld = {0}.
sqlstore.model.classdesc.primarytrackedfield=Feld {0} ist das prim\u00E4r \u00FCberwachte Feld.
sqlstore.model.classdesc.unsetconcurrencychk=Eigenschaft IN_CONCURRENCY_CHECK f\u00FCr lf {0} wird aufgehoben.
sqlstore.model.classdesc.unsetrefintegrityupdate=Eigenschaft REF_INTEGRITY_UPDATES f\u00FCr ff {0} wird aufgehoben.
sqlstore.model.classdesc.vcfield=Versionskonsistenzfeld = {0}.
sqlstore.model.fielddesc.addingfield=Feld {0}, das von Feld {1} \u00FCberwacht werden soll, wird hinzugef\u00FCgt
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} Von: {1} In: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: ausgeblendet {0} ... R\u00FCckgabe.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... R\u00FCckgabe.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} Gr\u00F6\u00DFe vor Bereinigung: {1}.
sqlstore.model.configcacheimpl.size_after={0} Gr\u00F6\u00DFe nach Bereinigung: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: Eine SCO-Instanz, die Eigentum eines anderen Objekts ist, kann nicht zugewiesen werden.
core.statemanager.cantnewoid=JDO76201: Neue Prim\u00E4rschl\u00FCsselinstanz der Klasse {0} konnte nicht erstellt werden.
core.statemanager.cantschedulejointable=JDO76202: Vereinigungstabelleneintrag von Klasse {0} und {1} wurde nicht geplant, da die Beziehungsfeldbeschreibung null ist.
core.statemanager.cantsetkeyfield=JDO76203: Wert f\u00FCr Prim\u00E4rschl\u00FCsselfeld {0} konnte nicht festgelegt werden.
core.statemanager.conflictingvalues=JDO76204: Widerspr\u00FCchliche Werte zwischen Feld {0} und Feld {1}, die derselben Spalte zugeordnet sind
core.statemanager.getfieldfailed=JDO76205: Feld konnte nicht abgerufen werden.
core.statemanager.invalidpk=JDO76206: Ung\u00FCltiges Null-Prim\u00E4rschl\u00FCsselfeld {0} beim Neuladen einer Instanz der persistenzf\u00E4higen Klasse {1}. Die ObjectId der Instanz ist {2}
core.statemanager.nopkupdate=JDO76207: Die Aktualisierung eines Prim\u00E4rschl\u00FCsselfeldes ist nicht zul\u00E4ssig.
core.statemanager.nopm=JDO76208: Der Statusmanager enth\u00E4lt keine Referenz zum Persistence Manager.
core.statemanager.notnavigable=JDO76209: Es wurde versucht, auf das Feld {0} der Klasse {1} zuzugreifen. Das Feld wurde zuvor nicht instanziiert und diese Klasse l\u00E4sst keine dynamische Navigation zu. Sie m\u00FCssen entweder das Feld anfordern, wenn Sie die Klasse abrufen, oder die dynamische Navigation zulassen, damit das Feld automatisch abgerufen wird, wenn darauf zugegriffen wird.
core.statemanager.objectnotfound=JDO76210: Objekt existiert nicht im Datenspeicher.
core.statemanager.poshiddenindex=JDO76211: Der Index auf einem ausgeblendeten Feld muss negativ ein, aber der aktuelle Index ist {0}.
core.statemanager.readonly=JDO76212: Es wurde versucht, das schreibgesch\u00FCtzte Feld {0} der Klasse {1} zu \u00E4ndern.
core.statemanager.releaselock.wrongthread=JDO76213: Dieser Thread {0} verf\u00FCgt \u00FCber keine StateManager-Sperre.
core.statemanager.setfieldfailed=JDO76214: Feld konnte nicht festgelegt werden.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Falscher Versuch, eine Instanz aus einer verwalteten Beziehung zu entfernen. Die Beziehung wird durch eine prim\u00E4re Schl\u00FCsselspalte auf der anderen Seite definiert. Ein L\u00F6schvorgang in einer Collection erfordert die Aktualisierung der Spalte auf der anderen Seite und die Aktualisierung des Prim\u00E4rschl\u00FCssels ist unzul\u00E4ssig. Aus diesem Grund kann eine Instanz aus einer verwalteten Beziehungs-Collection, die durch einen Prim\u00E4rschl\u00FCssel definiert ist, nur entfernt werden, indem die Instanz entweder explizit oder kaskadierend gel\u00F6scht wird.
core.statemanager.toomanyrows=JDO76215: Es wurden mehrere Zeilen f\u00FCr eine der der Klasse {0} zugeordneten Tabellen zur\u00FCckgegeben. Jede Tabelle, die einer Klasse zugeordnet ist, darf nur eine Zeile f\u00FCr jede Instanz des Objekts enthalten.
core.statemanager.copyFields.mismatch=JDO76216: Es wurde versucht, Felder aus einem StateManager in einen anderen zu kopieren, wobei diese StateManager Instanzen unterschiedlicher Typen verwalten: {0} und {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), dieser StateManager: {0}, anderer StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), Feld = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), Statusmanager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), Typ = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), Typ = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired ist: {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=Logging-Feld = {0} mit Wert = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=Markiertes Dirty Feld = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), Typ = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), Feld = {0}.
sqlstore.sqlstatemanager.marking={0} als vorhanden markieren.
sqlstore.sqlstatemanager.newtype=Neuer Typ: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Ausnahme: {0} Clone ... f\u00FCr Typ {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), Name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), Name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), Typ = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), Typ = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), Typ = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), Name = {0} f\u00FCr Status: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, Name = {0} f\u00FCr Status: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=Fremdes Feld verarbeiten ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): war Collection - entfernen.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): ist SCOCollection - aus BI entfernen.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): war SCOCollection - zur\u00FCcksetzen.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): Wert: {0} Typ: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), Name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), Feld realisiert = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), Name = {0}.
sqlstore.sqlstatemanager.recordingfield=Feld wird aufgezeichnet = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), Typ = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), Typ = {0}, Feld = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), SCO aufheben.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), Feld = {0}, Typ= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Collection wird zur\u00FCckgesetzt.
sqlstore.sqlstatemanager.resettingdate=Datum wird zur\u00FCckgesetzt.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), Abh\u00E4ngigkeit aufgel\u00F6st: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), Name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), Name = {0}.
sqlstore.sqlstatemanager.unsetmask=Masken f\u00FCr Feld aufheben = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), Typ = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), Name = {0},Wert = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), Name = {0}, Typ = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), sofortiges Zur\u00FCcksetzen erforderlich: Obj={0}, n\u00E4chstes={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() \u00FCbersprungen, Typ ={0}, Obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), Typ = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} Wert = {1} fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: Das Constraint ist ein \\"order by\\"-Constraint f\u00FCr das Feld {0}, das bereits in einem \\"order by\\"-Constraint angegeben wurde.
core.constraint.fielddisallowed=JDO76301: Der fieldName-Parameter wurde angegeben, aber ist f\u00FCr den Vorgang {0} nicht zul\u00E4ssig.
core.constraint.fieldrequired=JDO76302: Der fieldName-Parameter fehlt, aber der Vorgang {0} erfordert ein Feld.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() f\u00FCr OP_PARAMETER muss mit einem Wert vom Typ ParameterInfo aufgerufen werden.
core.constraint.illegalnode=JDO76304: Unzul\u00E4ssiger Constraint-Knoten {0} im SqlConstraint Stack.
core.constraint.illegalop=JDO76305: Der Vorgangsparameter wies einen unzul\u00E4ssigen Wert f\u00FCr {0} auf.
core.constraint.needfieldnamenode=JDO76306: Fehler im Constraint Stack. Erwartet wird ein Feldname.
core.constraint.needfieldnode=JDO76307: Fehler im Constraint Stack. Eine Feldbeschreibung wird erwartet.
core.constraint.needvalnode=JDO76308: Fehler im Constraint Stack. Ein Wert wird erwartet.
core.constraint.stackempty=JDO76309: Der Constraint Stack ist leer - nicht gen\u00FCgend Werte f\u00FCr die Operatorzahl.
core.constraint.unknownfield=JDO76310: Das Feld {0}, das im Abrufdeskriptor angegeben ist, ist kein Mitglied der Klasse {1}.
core.constraint.valdisallowed=JDO76311: Der Wertparameter wurde angegeben, ist jedoch f\u00FCr den Vorgang {0} nicht zul\u00E4ssig.
core.constraint.valrequired=JDO76312: Der Wertparameter fehlt, aber der Vorgang {0} erfordert einen Wert.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: Fehler beim Abrufen von Wert aus resultset bei Index {0} als resultType {1}. columnSqlType {2}. Ausnahmefehler: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: Abfragen f\u00FCr {0} sollten keine Projektionen f\u00FCr ein Beziehungsfeld aufweisen.
sqlstore.resultdesc.unknownfieldtype=JDO76317: Unbekannter Feldtyp {0} wurde angetroffen.
sqlstore.retrievedesc.toomanyprojections=JDO76318: Es kann nicht mehr als eine Projektion f\u00FCr eine RetrieveDesc festgelegt werden.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: Es kann nicht mehr als ein Ergebnistyp f\u00FCr eine RetrieveDesc festgelegt werden.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: Einer der Objekttypen, die diese Abfrage betreffen, hat die Konsistenzebene "bei Laden sperren". F\u00FCr die Durchsetzung dieser Konsistenzebene ist es erforderlich, dass der Datenspeicher die Sperrfunktion f\u00FCr die Aktualisierung auf der Zeilenebene unterst\u00FCtzt. Der Datenspeicher unterst\u00FCtzt die Sperrfunktion f\u00FCr die Aktualisierung auf der Zeilenebene nicht.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: LIKE ESCAPE-Klausel wird in dieser Datenbank nicht unterst\u00FCtzt.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: Drittes Argument f\u00FCr POSITION-Klausel muss 1 sein.
core.configuration.classnotmapped=JDO76323: Die Klasse {0} ist nicht zugeordnet.
core.configuration.classnotmappedtotable=JDO76324: Die Klasse {0} ist der Tabelle {1} nicht zugeordnet.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: Eine Bedingung f\u00FCr Vorgang {0} kann nie Root f\u00FCr eine Where-Klausel sein.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=SQL-Anweisung
sqlstore.sql.generator.statement.withinputvalues= Eingabewerte:
sqlstore.sql.generator.statement.withnoinputvalues= keine Eingabewerte.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=Deserialisierung = {0}.
sqlstore.resultdesc.marking_field=lokales Feld {0} als vorhanden markieren.
sqlstore.resultdesc.marking_foreign_field=fremdes Feld {0} als vorhanden markieren.
sqlstore.resultdesc.marking_key_field=Schl\u00FCsselfeld {0} als vorhanden markieren.
sqlstore.resultdesc.returning_field=Feld {0} als Projektion zur\u00FCckgeben.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn-Index: {0} Wert: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch {0}-Befehle werden ausgef\u00FChrt
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), Klasse = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), Klasse = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), Klasse = {0}, Anweisungen = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage ist nicht festgelegt.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage ist nicht festgelegt.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} wird aktualisiert.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: JDBC-SQLException beim Ausf\u00FChren der SQL-Anweisung:\n{0}.\nWeitere Informationen finden Sie in der SQLException.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: Mehrere nicht unterst\u00FCtzte SQL-Anweisungen f\u00FCr eine RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: Beim Versuch, den Wert f\u00FCr die Verkn\u00FCpfung {1} der Klasse {0} zu erhalten, wurden weniger Zeilen von der Datenbank zur\u00FCckgegeben als minimal f\u00FCr diese Verkn\u00FCpfung zul\u00E4ssig. Die minimal zul\u00E4ssige Anzahl von Zeilen ist {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: Die Datenbank ist nicht mit dem persistenten Modell konsistent. Bei dem Versuch, das Objekt zu erhalten, auf das durch die {1}-Verkn\u00FCpfung der {0}-Klasse verwiesen wurde, wurden {2} Elemente erhalten, aber nur 1 Element kann aufgenommen werden, da die zul\u00E4ssige Obergrenze f\u00FCr die Verkn\u00FCpfung bei 1 liegt.
core.persistencestore.toomanyrows=JDO76405: Beim Versuch, den Wert f\u00FCr die Verkn\u00FCpfung {1} der Klasse {0} abzurufen, wurden mehr Zeilen von der Datenbank zur\u00FCckgegeben als maximal f\u00FCr diese Verkn\u00FCpfung zul\u00E4ssig. Die maximal zul\u00E4ssige Anzahl von Zeilen ist {2}.
core.store.concurrentaccess=JDO76406: Ausnahme durch gleichzeitigen Zugriff: Objekt f\u00FCr {0} wurde aktualisiert oder in einer anderen Transaktion gel\u00F6scht.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: Fehler beim Schlie\u00DFen der SQL-Ergebnismenge. Ausnahmefehler: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: Fehler beim Schlie\u00DFen der SQL-Anweisung. Ausnahmefehler: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: Mehrere nicht unterst\u00FCtzte Abfragepl\u00E4ne f\u00FCr eine RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), betroffene Zeilen = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; Batch hinzuf\u00FCgen.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), betroffene Zeilen = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; Batch zur\u00FCcksetzen.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: Herstellertyp = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: Neuer ''{0}'' muss gr\u00F6\u00DFer sein als bzw. gleich sein wie aktueller ''{1}''.
connection.connectionmanager.badvalue=JDO76501: Ung\u00FCltiger Wert f\u00FCr ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: Timeout f\u00FCr Verbindung \u00FCberschritten.
connection.connectionmanager.getconnection.mismatch=JDO76503: Connection im Pool weist nicht denselben Benutzerkontext auf.
connection.connectionmanager.isdown=JDO76504: Der Verbindungsmanager wird heruntergefahren.
connection.connectionmanager.maxpool=JDO76505: Connection Pool wird zu umfangreich.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval muss gr\u00F6\u00DFer sein als null und kleiner als oder gleich MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait muss gr\u00F6\u00DFer als oder gleich null sein.
connection.connectionmanager.nulldriver=JDO76508: Wert NULL f\u00FCr Treibername.
connection.connectionmanager.nullurl=JDO76509: Wert NULL f\u00FCr URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' muss gr\u00F6\u00DFer als oder gleich 'minPool' sein.
connection.connectionmanager.threaditerupted=JDO76511: Thread unterbrochen.
connection.connectionmanager.zero=JDO76512: ''{0}'' muss gr\u00F6\u00DFer als oder gleich null sein.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: Eigenschaften f\u00FCr Standarddatenbank konnten nicht geladen werden.
sqlstore.database.dbvendor.init.default=JDO76514: -->Eigenschaft f\u00FCr Herstellertyp {0} konnte nicht geladen werden. Verwendet werden Standardwerte.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: Klasse {0} konnte nicht instanziiert werden.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: Spalte f\u00FCr Anweisung konnte nicht definiert werden.
sqlstore.database.oracle.nooracleavailable=JDO76517: Bei der Initialisierung der Oracle-Ressourcen-Factory ''{0}'' konnte weder eine Instanz von oracle.jdbc.OraclePreparedStatement noch von oracle.jdbc.driver.OraclePreparedStatement abgerufen werden. Die Oracle-spezifische Optimierung wird deaktiviert. Wenn Instanzen, die diese Ressource verwenden, Bind-Werte f\u00FCr Spalten ben\u00F6tigen, die der Fixed Char-Spalte zugeordnet sind, werden die Werte mit Leerzeichen aufgef\u00FCllt, um die in der zugeh\u00F6rigen dbschema-Datei angegebene L\u00E4nge zu erreichen.
sqlstore.database.oracle.fixedcharpadded=JDO76518: Wert "{0}" ist an eine CHAR-Spalte gebunden. Dies erfordert eine besondere Behandlung bei Oracle. Da die Klasse OraclePreparedStatement nicht vom Treiber abgerufen werden konnte, wird der Wert mit Leerzeichen aufgef\u00FCllt, bis die in der erfassten dbschema-Datei angegebene L\u00E4nge von {1} erreicht ist.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: Herstellertyp f\u00FCr den Datenspeicher konnte nicht identifiziert werden.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: Fehler beim Abrufen von Informationen zur Datenbank. Folgender Ausnahmefehler trat auf:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: gefunden {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: neu {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: frei {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: Verbindung beendet.
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact.
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: Verbindung freigegeben.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: Verbindung beendet.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: in freeList gesetzt.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: Verbindung ersetzt.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: Verbindung beendet.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: Verbindung beendet.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit:
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: disassociateXact steht aus.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: Verbindung beendet.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties(): {0} mit: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}] vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} f\u00FCr {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} f\u00FCr {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} f\u00FCr {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} f\u00FCr {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} f\u00FCr {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} f\u00FCr {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} f\u00FCr {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: Methode {0} darf nicht in einer nicht verwalteten Umgebung aufgerufen werden.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: JNDI-Suche nach cmp-resource ''{0}'' war nicht erfolgreich.
JDO76604.diag.cause.1=CMP-Ressource mit diesem JNDI-Namen ist nicht mit dieser Instanz registriert.
JDO76604.diag.cause.2=JNDI-Name f\u00FCr die CMP-Ressource ist falsch geschrieben.
JDO76604.diag.check.1=\u00DCberpr\u00FCfen Sie den JNDI-Namen f\u00FCr die zu verwendende Ressource.
JDO76604.diag.check.2=\u00DCberpr\u00FCfen Sie den JNDI-Namen der im Modul angegebenen CMP-Ressource.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: JNDI-Suche nach cmp-resource ''{0}'' hat eine Instanz eines unerwarteten Typs zur\u00FCckgegeben: {1}.
JDO76605.diag.cause.1=CMP-Ressource mit diesem JNDI-Namen referenziert nicht die jdbc-resource oder persistence-manager-factory-resource.
JDO76605.diag.cause.2=JNDI-Name f\u00FCr die CMP-Ressource ist falsch geschrieben.
JDO76605.diag.check.1=\u00DCberpr\u00FCfen Sie den JNDI-Namen f\u00FCr die zu verwendende Ressource.
JDO76605.diag.check.2=\u00DCberpr\u00FCfen Sie den JNDI-Namen der im Modul angegebenen CMP-Ressource.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Verbindung mit JNDI-Name ''{0}'' wird abgerufen.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: Ung\u00FCltiger Zugriff von CMPHelper. Diese Klasse wird nur f\u00FCr die CMP-Unterst\u00FCtzung verwendet und sollte au\u00DFerhalb eines Application Servers nicht aufgerufen werden.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: DataSource ist nicht vom erwarteten Typ. Erwartet wird: com.sun.appserv.jdbc.DataSource, erhalten: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=Dieses Feld {0} ist kein Mitglied der Klasse {1}.
core.generic.unknownexception=Unbekannte Ausnahme erhalten.
core.generic.nullparam=Der {0}-Parameter ist null.
core.generic.notinstanceof=Das Objekt der Klasse {0} ist keine Instanz von {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Klasse {0} konnte nicht geladen werden.
sqlstore.exception.log=Ausnahmefehler.
jdo.lifecycle.deleted.accessField=Zugriff auf Feld einer gel\u00F6schten Instanz nicht m\u00F6glich.
